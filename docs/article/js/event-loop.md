# JavaScript 运行机制

## JS 为什么是单线程

首先要知道，JS 是单线程的，因为其作为浏览器脚本语言，主要用途是与用户互动和操作 DOM,这决定了它只能是单线程，否则会带来很复杂的同步问题。比如 JavaScript 有两个线程，一个在增加 DOM，一个在删除 DOM，那该以哪个线程为主呢。

通过 HTML5 新增的 Web Worker 可以允许 JavaScript 创建子线程，但子线程完全是受主线程控制的，且不得操作 DOM。

## 浏览器

### 浏览器包含哪些进程

- Browser 进程

  - 浏览器的主进程(负责协调、主控)，该进程只有一个

  - 负责浏览器界面显示，与用户交互。如前进，后退等

  - 负责各个页面的管理，创建和销毁其他进程

  - 将渲染(Renderer)进程得到的内存中的 Bitmap(位图)，绘制到用户界面上

  - 网络资源的管理，下载等

- 第三方插件进程

  - 每种类型的插件对应一个进程，当使用该插件时才创建

- GPU 进程

  - 该进程也只有一个，用于 3D 绘制等等

- 渲染进程(重)

  - 即通常所说的浏览器内核(Renderer 进程，内部是多线程)

  - 每个 Tab 页面都有一个渲染进程，互不影响

  - 要作用为页面渲染，脚本执行，事件处理等

### 渲染进程 Renderer 的主要线程

#### GUI 渲染线程

- 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等

  - 解析 html 代码(HTML 代码本质是字符串)转化为浏览器认识的节点，生成 DOM 树，也就是 DOM Tree
  - 解析 css，生成 CSSOM(CSS 规则树)
  - 把 DOM Tree 和 CSSOM 结合，生成 Rendering Tree(渲染树)

- 当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)

- 当我们修改元素的尺寸，页面就会回流(Reflow)

- 当页面需要 Repaing 和 Reflow 时 GUI 线程执行，绘制页面

- 回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免 Reflow 和 Repaint

- GUI 渲染线程与 JS 引擎线程是互斥的

  - 当 JS 引擎执行时 GUI 线程会被挂起(相当于被冻结了)

  - GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行

#### JS 引擎线程

- JS 引擎线程就是 JS 内核，负责处理 Javascript 脚本程序(例如 V8 引擎)
- JS 引擎线程负责解析 Javascript 脚本，运行代码
- JS 引擎一直等待着任务队列中任务的到来，然后加以处理
  - 浏览器同时只能有一个 JS 引擎线程在运行 JS 程序，所以 js 是单线程运行的
  - 一个 Tab 页(renderer 进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序
- GUI 渲染线程与 JS 引擎线程是互斥的，js 引擎线程会阻塞 GUI 渲染线程
  - 就是我们常遇到的 JS 执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)
  - 例如浏览器渲染的时候遇到`<script>`标签，就会停止 GUI 的渲染，然后 js 引擎线程开始工作，执行里面的 js 代码，等 js 执行完毕，js 引擎线程停止工作，GUI 继续渲染下面的内容。所以如果 js 执行时间太长就会造成页面卡顿的情况

#### 事件触发线程

- 属于浏览器而不是 JS 引擎，用来控制事件循环，并且管理着一个事件队列(task queue)
- 当 js 执行碰到事件绑定和一些异步操作(如 setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待 js 引擎线程空闲时来处理。
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
- 因为 JS 是单线程，所以这些待处理队列中的事件都得排队等待 JS 引擎处理

#### 定时触发器线程

- setInterval 与 setTimeout 所在线程
- 浏览器定时计数器并不是由 JavaScript 引擎计数的(因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)
- 通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待 JS 引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程
- W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms

#### 异步 http 请求线程

- 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行
- 简单说就是当执行到一个 http 异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是 http 状态变化)，再把回调函数添加到事件队列，等待 js 引擎线程来执行

## 事件循环(Event loop)

JavaScript 分为同步任务和异步任务。
同步任务都在主线程即 JS 引擎线程上执行，会形成一个执行栈。
主线程之外，事件触发线程管理着一个任务队列，异步任务有了运行结果，就在任务队列之中放一个事件回调。

当执行栈中的同步任务执行完毕后(即 JS 引擎线程空闲了)，系统就会读取任务队列，将可运行的异步任务添加到执行栈中，开始执行
看下面的代码:

```js
let setTimeoutCallBack = function() {
  console.log('我是定时器回调');
};
let httpCallback = function() {
  console.log('我是http请求回调');
};

// 同步任务
console.log('我是同步任务1');

// 异步定时任务
setTimeout(setTimeoutCallBack, 1000);

// 异步http请求任务
ajax.get('/info', httpCallback);

// 同步任务
console.log('我是同步任务2');
```

首先执行 console.log('我是同步任务 1')

然后 执行到 setTimout 时会移交给定时器线程，通知定时器线程 1s 后将 setTimeoutCallBack 这个回调交给事件触发线程处理，接受到后，将它加入到 事件触发线程所管理的事件队列中等待执行

然后，执行 http 请求，会移交给异步 http 请求线程 发送网络请求，请求成功后将 httpCallback 这个回调交由事件触发线程处理，接收到后将它加入到事件触发线程所管理的事件队列中等待执行

再执行 console.log('我是同步任务 2')

到此，JS 主线程空闲，开始处理事件触发线程，先查看其中的事件队列中是否有需要执行的回调函数，如果有则则将事件队列的回调事件加入执行栈中，开始执行回调，如果事件队列中没有回调，JS 引擎线程会一直发起询问，直到有为止

到了这里我们发现，浏览器上的所有线程的工作都很单一且独立，非常符合单一原则

定时触发线程只管理定时器且只关注定时不关心结果，定时结束就把回调扔给事件触发线程

异步 http 请求线程只管理 http 请求同样不关心结果，请求结束把回调扔给事件触发线程

事件触发线程只关心异步回调入事件队列

而我们 JS 引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的事件循环(Event Loop)

## 宏任务(macrotask)与微任务(microtask)

#### 宏任务

我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他

由于 JS 引擎线程和 GUI 渲染线程是互斥的关系，浏览器为了能够使宏任务和 DOM 任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI 渲染线程开始工作，对页面进行渲染

```js
宏任务 -> GUI渲染 -> 宏任务 -> ...
```

常见的宏任务

- 主代码块
- setTimeout
- setInterval
- setImmediate ()-Node
- requestAnimationFrame ()-浏览器

#### 微任务

ES6 新引入了 Promise 标准，同时浏览器实现上多了一个 microtask 微任务概念，在 ECMAScript 中，microtask 也被称为 jobs

我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务

当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完

```js
宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
```

常见微任务

- process.nextTick ()-Node
- Promise.then()
- catch
- finally
- Object.observe
- MutationObserver

## 整体运行机制总结

首先，整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务、异步任务两部分

同步任务会直接进入主线程依次执行

异步任务会再分为宏任务和微任务

宏任务进入到 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中

微任务也会进入到另一个 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中

当主线程内的任务执行完毕，主线程为空时，会检查微任务的 Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务（先微后宏）

上述过程会不断重复，这就是 Event Loop，比较完整的事件循环

## 关于 Promise

```js
new Promise(resolve => {
  console.log(1);
  resolve();
}).then(() => {
  console.log(2);
});
console.log(3);
```

输出 1 2 3

前面的 new Promise() 这一部分是一个构造函数，这是一个同步任务

后面的 .then() 才是一个异步微任务，这一点是非常重要的

## 关于 async/await 函数

async/await 本质上还是基于 Promise 的一些封装，而 Promise 是属于微任务的一种

所以在使用 await 关键字与 Promise.then 效果类似

```js
setTimeout(() => console.log(4));

async function test() {
  console.log(1);
  await Promise.resolve();
  console.log(3);
}
test();
console.log(2);
```

上述代码输出 1 2 3 4

可以理解为，await 以前的代码，相当于与 new Promise 的同步代码，await 以后的代码相当于 Promise.then 的异步

## 参考

本节相关知识，暂时没有在书中找到，通过掘金大神总结的来进行学习，日后需要自己研究总结。

[「硬核 JS」一次搞懂 JS 运行机制](https://juejin.im/post/5e22b391f265da3e204d8c14#heading-8)
